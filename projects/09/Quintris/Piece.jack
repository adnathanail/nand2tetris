// Copyright (c) 2025-03-08 Alex Nathanail
// All rights reserved

/** A single Quintris piece */
class Piece {
   // Side length of squares making up the piece in pixels (16)
   static int size;
   // Number of squares per piece (5)
   static int num_squares;
   // Width and height of screen in px
   static int screen_width_px;
   static int screen_height_px;
   // Width and height of screen in grid blocks
   static int screen_width;
   static int screen_height;

   // Location of the square's top-left corner, in grid blocks relative to size
   //   (e.g. x = 3, is 16 * 3 = 48 in pixels)
   field int x, y;
   // Flattened n*2 Array of relative offsets to create a multi-square shape
   //   e.g. (0, 0, 0, 1, 0, 2, 0, 3, 1, 3)
   //   represents the 2D array ((0, 0), (0, 1), (0, 2), (0, 3) (1, 3))
   //   and forms an L shape
   field Array squares;
   // Width and height of piece (in grid blocks)
   field int width;
   field int height;

   function void initStatic() {
      // Initialise classes static variables (should be called only once)
      let size = 16;
      let num_squares = 5;
      let screen_width_px = 512;
      let screen_height_px = 256;

      // Calculate some static variables
      let screen_width = screen_width_px / size;
      let screen_height = screen_height_px / size;

      return;
   }

   method void _setSquare(int square_index, int x, int y) {
      let squares[square_index * 2] = x;
      let squares[(square_index * 2) + 1] = y;

      let width = Math.max(width, x + 1);
      let height = Math.max(height, y + 1);

      return;
   }

   /** Constructs a new square with a given location and size. */
   constructor Piece new() {
      // Initialise pieces starting position
      let x = 0;
      let y = 0;

      // Initialise array of square offsets
      let squares = Array.new(num_squares * 2);

      do _setSquare(0, 0, 0);
      do _setSquare(1, 1, 0);
      do _setSquare(2, 0, 1);
      do _setSquare(3, 1, 1);
      do _setSquare(4, 1, 2);

      // Draw piece on the screen
      do draw(true);
      return this;
   }

   /** Disposes this piece. */
   method void dispose() {
      do squares.dispose();
      do Memory.deAlloc(this);
      return;
   }

   /** Draws the piece on the screen. */
   method void draw(boolean color) {
      var int i;

      var int square_x;
      var int square_y;

      do Screen.setColor(color);
      let i = 0;
      while (i < num_squares) {
         let square_x = x + squares[i * 2];
         let square_y = y + squares[(i * 2) + 1];
         do Screen.drawRectangle(square_x * size + 1, square_y * size + 1, (square_x + 1) * size - 1, (square_y + 1) * size - 1);
         let i = i + 1;
      }
      return;
   }

   /** Checks whether the piece can "drop" any further */
   method boolean canDrop() {
      return (x + width) < screen_width;
   }

   /** Checks whether the piece can move up */
   method boolean canMoveUp() {
      return y > 0;
   }

   /** Checks whether the piece can move down */
   method boolean canMoveDown() {
      return (y + height) < screen_height;
   }

   /** "Drop"s the piece 1 space to the right */
   method void drop() {
      do draw(false);
      let x = x + 1;
      do draw(true);
      return;
   }

   /** Move the piece 1 space up */
   method void moveUp() {
      do draw(false);
      let y = y - 1;
      do draw(true);
      return;
   }

   /** Move the piece 1 space down */
   method void moveDown() {
      do draw(false);
      let y = y + 1;
      do draw(true);
      return;
   }
}
