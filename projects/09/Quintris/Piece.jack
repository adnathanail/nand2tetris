// Copyright (c) 2025-03-08 Alex Nathanail
// All rights reserved

/** A single Quintris piece */
class Piece {
   // Number of squares per piece (5)
   static int num_squares;

   field QuintrisGame game;
   // Location of the square's top-left corner, in grid blocks relative to size
   //   (e.g. x = 3, is 16 * 3 = 48 in pixels)
   field int x, y;
   // Flattened n*2 Array of relative offsets to create a multi-square shape
   //   e.g. (0, 0, 0, 1, 0, 2, 0, 3, 1, 3)
   //   represents the 2D array ((0, 0), (0, 1), (0, 2), (0, 3) (1, 3))
   //   and forms an L shape
   field Array squares;
   // Width and height of piece (in grid blocks)
   field int width;
   field int height;

   method void _setSquare(int square_index, int x, int y) {
      let squares[square_index * 2] = x;
      let squares[(square_index * 2) + 1] = y;

      let width = Math.max(width, x + 1);
      let height = Math.max(height, y + 1);

      return;
   }

   /** Constructs a new square with a given location and size. */
   constructor Piece new(Game game) {
      let game = game;

      // Initialise static variables
      let num_squares = 5;

      // Initialise pieces starting position
      let x = 0;
      let y = 0;

      // Initialise array of square offsets
      let squares = Array.new(num_squares * 2);

      do _setSquare(0, 0, 0);
      do _setSquare(1, 1, 0);
      do _setSquare(2, 0, 1);
      do _setSquare(3, 1, 1);
      do _setSquare(4, 1, 2);

      // Draw piece on the screen
      do draw(true);
      return this;
   }

   /** Disposes this piece. */
   method void dispose() {
      do squares.dispose();
      do Memory.deAlloc(this);
      return;
   }

   /** Draws the piece on the screen. */
   method void draw(boolean color) {
      var int i;

      var int square_x;
      var int square_y;

      do Screen.setColor(color);
      let i = 0;
      while (i < num_squares) {
         let square_x = x + squares[i * 2];
         let square_y = y + squares[(i * 2) + 1];
         do Screen.drawRectangle(square_x * game.getSize() + 1, square_y * game.getSize() + 1, (square_x + 1) * game.getSize() - 1, (square_y + 1) * game.getSize() - 1);
         let i = i + 1;
      }
      return;
   }

   /** Checks whether the piece can "drop" any further */
   method boolean canDrop() {
      return (x + width) < game.getScreenWidth();
   }

   /** Checks whether the piece can move up */
   method boolean canMoveUp() {
      return y > 0;
   }

   /** Checks whether the piece can move down */
   method boolean canMoveDown() {
      return (y + height) < game.getScreenHeight();
   }

   /** "Drop"s the piece 1 space to the right */
   method void drop() {
      do draw(false);
      let x = x + 1;
      do draw(true);
      return;
   }

   /** Move the piece 1 space up */
   method void moveUp() {
      do draw(false);
      let y = y - 1;
      do draw(true);
      return;
   }

   /** Move the piece 1 space down */
   method void moveDown() {
      do draw(false);
      let y = y + 1;
      do draw(true);
      return;
   }
}
