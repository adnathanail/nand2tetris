// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static int ram, heap, freeList;

    /** Initializes the class. */
    function void init() {
        let ram = 0;  // Pointer used to allow direct access to read/write RAM
        let heap = 2048;  // Address of the start of the heap

        // "pseudo" linked list where for a given pointer into a list item,
        //    the first value is the address of the next item
        //    the second value is the length of the current item
        // used to contain all of the available memory segments
        let freeList = heap;
        let freeList[0] = -1;  // next
        let freeList[1] = 14336;  // length: 2^14 - 2048
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let ram[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var int pointer, out;

        let pointer = freeList;
        // iterate through the free list until we find a large enough segment for the allocation size
        while ((size + 2) > pointer[1]) {
            let pointer = pointer[0];
        }

        // take a portion from the end of this segment, with space for the allocation size
        //   (plus 2, for the next pointer, and segment size)
        let out = (pointer + pointer[1]) - (size + 2);
        // set the size of the segment
        let out[1] = size;
        // reduce the available length of the memory segment
        let pointer[1] = pointer[1] - (size + 2);

        // return the newly allocated segment (plus 2, as the user shouldn't overwrite our memory allocation info)
        return out + 2;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        var int pointer;

        let pointer = freeList;
        // follow the freeList until we find the last value
        while (~(pointer[0] = (-1))) {
            let pointer = pointer[0];
        }
        let pointer[0] = o - 2;
        // set the next segment to be -1, to mark the new end of the list
        let o[-2] = -1;
        return;
    }
    function void defrag() {
        // Naive defrag that only consolidates adjacent memory sections
        var int pointer, next_pointer;
        let pointer = freeList;
        // If we only have 1 item in the freeList, then there is nothing to defrag
        if (pointer[0] = (-1)) {
            return;
        }
        let next_pointer = pointer[0];
        // Go through each item in the list
        while (~(pointer[0] = (-1))) {
            // If the end of the next free segment, equals the start of this one
            if (pointer = ((next_pointer + next_pointer[1]) + 2)) {
                // Add the length from the next segment to the current segment
                let pointer[1] = pointer[1] + (next_pointer[1] + 2);
                // Point the next of the current segment at the next of the old next segment
                let pointer[0] = next_pointer[0];
            }
            // Move to the next segment
            let pointer = pointer[0];
            let next_pointer = pointer[0];
        }
        return;
    }
}
